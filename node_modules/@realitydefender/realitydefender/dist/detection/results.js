"use strict";
/**
 * Handling detection results
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMediaResult = getMediaResult;
exports.getMediaResults = getMediaResults;
exports.formatResult = formatResult;
exports.formatResults = formatResults;
exports.getDetectionResult = getDetectionResult;
exports.getDetectionResults = getDetectionResults;
const constants_1 = require("../core/constants");
const errors_1 = require("../errors");
const async_1 = require("../utils/async");
/**
 * Get the raw media result from the API
 * @param client HTTP client
 * @param requestId Request ID
 * @returns Raw media response
 */
async function getMediaResult(client, requestId) {
    try {
        const path = `${constants_1.API_PATHS.MEDIA_RESULT}/${requestId}`;
        return await client.get(path);
    }
    catch (error) {
        if (error instanceof errors_1.RealityDefenderError) {
            throw error;
        }
        throw new errors_1.RealityDefenderError(`Failed to get result: ${error.message}`, 'unknown_error');
    }
}
async function getMediaResults(client, pageNumber = 0, size = 10, name = null, startDate = null, endDate = null) {
    try {
        const path = `${constants_1.API_PATHS.ALL_MEDIA_RESULTS}/${pageNumber}`;
        const params = {
            size: size,
        };
        if (name) {
            params['name'] = name;
        }
        if (startDate) {
            params['startDate'] =
                `${startDate.getFullYear()}-${startDate.getMonth() + 1}-${startDate.getDate()}`;
        }
        if (endDate) {
            params['endDate'] =
                `${endDate.getFullYear()}-${endDate.getMonth() + 1}-${endDate.getDate()}`;
        }
        return await client.get(path, params);
    }
    catch (error) {
        if (error instanceof errors_1.RealityDefenderError) {
            throw error;
        }
        throw new errors_1.RealityDefenderError(`Failed to get paginated results: ${error.message}`, 'unknown_error');
    }
}
/**
 * Format the raw API response into a user-friendly result
 * @param response Raw API response
 * @returns Simplified detection result
 */
function formatResult(response) {
    // Extract active models (not NOT_APPLICABLE)
    const activeModels = response.models.filter(model => model.status !== 'NOT_APPLICABLE' && model.code !== 'not_applicable');
    // Replace FAKE with MANIPULATED in response status
    const status = response.resultsSummary.status === 'FAKE'
        ? 'MANIPULATED'
        : response.resultsSummary.status;
    // Normalize the final score from 0-100 to 0-1 range
    const normalizedScore = response.resultsSummary.metadata.finalScore !== null
        ? response.resultsSummary.metadata.finalScore / 100
        : null;
    return {
        requestId: response.requestId,
        status: status,
        score: normalizedScore,
        models: activeModels.map(model => ({
            name: model.name,
            // Replace FAKE with MANIPULATED in model status
            status: model.status === 'FAKE' ? 'MANIPULATED' : model.status,
            // Score between 0-1 range or null if not available
            score: model.predictionNumber,
        })),
    };
}
/**
 * Format the all media API response into a user-friendly result
 * @param response Raw API response
 * @returns Simplified detection result list
 */
function formatResults(response) {
    const result = {
        totalItems: response.totalItems ?? 0,
        currentPageItemsCount: response.currentPageItemsCount ?? 0,
        totalPages: response.totalPages ?? 0,
        currentPage: response.currentPage ?? 0,
        items: [],
    };
    if (response.mediaList) {
        for (const item of response.mediaList) {
            result.items.push(formatResult(item));
        }
    }
    return result;
}
/**
 * Get detection results for a media request
 * @param client HTTP client
 * @param requestId Request ID
 * @param options Detection options for polling configuration
 * @returns Detection results
 */
async function getDetectionResult(client, requestId, options = {}) {
    let attempts = 0;
    const { maxAttempts = Number.MAX_SAFE_INTEGER, pollingInterval = constants_1.DEFAULT_POLLING_INTERVAL, } = options;
    while (attempts < maxAttempts) {
        const mediaResult = await getMediaResult(client, requestId);
        // If the status is not ANALYZING, return the results immediately
        if (mediaResult.resultsSummary.status !== 'ANALYZING') {
            return formatResult(mediaResult);
        }
        // If we've reached the maximum attempts, return the results even if still analyzing
        if (++attempts >= maxAttempts) {
            return formatResult(mediaResult);
        }
        // Wait for the polling interval before trying again
        await (0, async_1.sleep)(pollingInterval);
    }
    // This should never be reached, but TypeScript needs it
    const mediaResult = await getMediaResult(client, requestId);
    return formatResult(mediaResult);
}
async function getDetectionResults(client, pageNumber = 0, size = 10, name = null, startDate = null, endDate = null, options = {}) {
    let attempts = 0;
    const { maxAttempts = Number.MAX_SAFE_INTEGER, pollingInterval = constants_1.DEFAULT_POLLING_INTERVAL, } = options;
    while (attempts < maxAttempts) {
        try {
            const mediaResults = await getMediaResults(client, pageNumber, size, name, startDate, endDate);
            return formatResults(mediaResults);
        }
        catch (error) {
            if (++attempts >= maxAttempts) {
                throw new errors_1.RealityDefenderError(`Failed to get paginated results: ${error.message}`, 'unknown_error');
            }
            // Wait for the polling interval before trying again
            await (0, async_1.sleep)(pollingInterval);
        }
    }
    throw new errors_1.RealityDefenderError(`Failed to get detection result list after ${attempts} attempts`, 'timeout');
}
